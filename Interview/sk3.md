1. node 捕获错误 [参考](https://juejin.im/post/6858910962339856397)

2. 所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。

   函数声明： 函数声明，函数表达式( var fn = function(){} )

3. 一段JS代码： 先编译，后执行

   编译阶段和执行阶段： 词法分析、语法解析、代码优化、代码生成

   编制完之后会生成，执行上下文+可执行代码

   在执行上下文中存在一个**变量环境的对象**，可执行代码编译为**字节码(JIT)**, 执行的时候才赋值

   <u>调用函数时，先编译，创建该函数的执行上下文，再执行。</u>

   箭头函数不会创建自身的执行上下文，所有没有this

4. 调用栈： 什么是调用，执行一个函数；什么是栈，就是一个先进后出的数据结构。一直进，不出，就会出现栈溢出。( >= 250001)

5. 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。

   变量是通过作用域链来查找的，

   词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符，

   词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。

   

6. 闭包  <u>Closure</u>

   根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为**闭包**

   优点：a、读取函数内部的变量；b、让这些变量的值始终保持在内存中，<u>堆中有一块专属背包</u>，

   缺点：a、函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

   ​			b、有可能导致this值混乱

   内存模型怎么解释这个问题？

   

7. 全局执行上下文中的 this 是指向 window 对象的。<u>这也是 this 和作用域链的唯一交点</u>，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。

8. 执行一个构造函数( CreateObj )实例化，JS引擎做的工作

   a、首先创建了一个空对象 tempObj；

   b、接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；

   c、然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；

   d、最后返回 tempObj 对象。

9. 进程 & 线程

   **进程是资源分配的最小单位，线程是CPU调度的最小单位**

   线程在进程下行进（单纯的车厢无法运行）

   一个进程可以包含多个线程（一辆火车可以有多个车厢）

   不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）

   同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

   进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）

   进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）

   

10. 浏览器垃圾回收器

    a、栈中垃圾回收， 是通过移动栈中顶部 ESP 指针 来回收，当一个函数执行完之后，ESP指针往下移动，并且销毁该函数保存在栈中的执行上下文。

![](https://static001.geekbang.org/resource/image/b8/f3/b899cb27c0d92c31f9377db59939aaf3.jpg)

​		b、堆中垃圾回收

11.  用CSS3实现动画是不是不会影响主线程，和用JS实现动画会影响主线程，这个说法对么

    a、部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。b、JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！
    
12. TYPESCRIPT

    为什么学习TS

    - TypeScript快速、简单，最重要的是，容易学习。
    - TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。
    - TypeScript在编译时提供了错误检查功能。它将编译代码，如果发现任何错误，它将在运行脚本之前突出显示这些错误。
    - TypeScript支持所有JavaScript库，因为它是JavaScript的超集。
    - TypeScript通过使用继承来支持可重用性。
    - TypeScript使应用程序开发尽可能的快速和简单，并且TypeScript的工具支持为我们提供了自动完成、类型检查和源文档。
    - TypeScript支持最新的JavaScript特性，包括ECMAScript 2015。
    - TypeScript提供了ES6的所有优点和更高的生产力。
    - TypeScript支持静态类型、强类型、模块、可选参数等。
    
13. ES6 COMMON 差异

    a、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

    b、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

    c、第二个差异是因为 CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

14. 异常捕获，收集日志

    a、全局

    window.addEventListener(‘error’) / window.addEventListener(“unhandledrejection”) ；

    vue、react都有自己的错误采集接口；

    对 全局 request 函数进行二次包装

    b、单点捕获

    try…catch；

    专门写一个函数来收集异常信息，在异常发生时，调用该函数；

    专门写一个函数来包裹其他函数，得到一个新函数，该新函数运行结果和原函数一模一样，只是在发生异常时可以捕获异常；

15. [多进程模型](https://blog.csdn.net/hongchh/article/details/79898816)

    child_process

    1. 父子进程间通信，
    2.  master分发请求给worker处理，
    3. worker监听同一个端口号，进行抢占式调度

    进程重启

    1. 在Node中，子进程退出时，会在父进程中触发`exit`事件。父进程只需通过监听该事件便可知道子进程是否退出，并在退出的时候做出相应的处理。

    cluster

    1. cluster.isMaster 是主进程

       

    egg

    - 提供基于 Egg [定制上层框架](https://eggjs.org/zh-cn/advanced/framework.html)的能力
    - 高度可扩展的[插件机制](https://eggjs.org/zh-cn/basics/plugin.html)
    - 内置[多进程管理](https://eggjs.org/zh-cn/advanced/cluster-client.html)
    - 基于 [Koa](http://koajs.com/) 开发，性能优异
    - 框架稳定，测试覆盖率高
    - [渐进式开发](https://eggjs.org/zh-cn/tutorials/progressive.html)

    

16. 跨域

    1. src，link 都没有受同源策略的限制

    callback参数定义的方法是需要前后端定义好的，具体什么名字，商讨好就可以了。其实jsonp的整个过程就类似于前端声明好一个函数，后端返回执行函数。

    2. CORS

       预检请求

       

17. 项目架构

    较强的产品理解能力；

    持续不断的学习能力，敢于尝试新的技术；

    流程和规范化；

    团队合作，热团队中的每个人都能明确自己的职责，并且很好维护这种关系；



18. 前端性能优化

    服务端优化，做代理缓存，

    a、图片处理，懒加载等静态资源优化，

    b、合并资源，

    c、合适使用http缓存，利用好浏览器缓存

    d、按需加载对应的 js 文件，不全部加载

    

19. 读取二维码信息
20. 

